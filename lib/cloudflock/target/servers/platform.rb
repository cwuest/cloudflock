require 'cpe'
require 'cloudflock'
require 'fog'

module CloudFlock; module Target; module Servers
  # Public: Map host specifications to Image and Flavor IDs in Rackspace Cloud.
  #
  # Examples
  #
  #   platform = Platform.new(cpe, fog)
  #   platform.get_appropriate_flavors
  #   # => [<Fog::Compute::RackspaceV2::Flavor>, ...]
  #
  #   platform.to_s
  #   # => "CentOS Linux 6.4"
  class Platform
    # Public: Initialize the Platform object.
    #
    # cpe - CPE object to use in determining image ID.
    # fog - Fog Compute object used to obtain flavor and image maps.
    #       (default: nil)
    #
    # Raises ArgumentError if anything but a CPE object is passed.
    # Raises KeyError if the CPE object doesn't have vendor and version
    # defined.
    def initialize(cpe, fog = nil)
      unless cpe.is_a?(CPE)
        raise(ArgumentError, Errstr::NOT_CPE)
      end
      if cpe.vendor.nil? or cpe.version.nil?
        raise(KeyError, Errstr::CPE_INCOMPLETE)
      end

      @cpe = cpe
      build_maps(fog)
    end

    # Public: Generate a String describing the platform's name/version.
    #
    # Returns a String.
    def to_s
      "#{@cpe.distro.capitalize} #{@cpe.product.gsub(/_/, ' ').capitalize} " \
      "#{@cpe.version}"
    end

    # Public: Given a resource map (e.g. generated by profiling a host), 
    # determine which flavors would be appropriate as migration targets.
    #
    # resource_map - Hash containing memory and hard disk usage information
    #                from the source host:
    #                :ram - Hash containing memory usage information
    #                       :mem_used  - Amount of memory used in MiB.
    #                                    (default: 0)
    #                       :swapping? - Whether the source host is swapping.
    #                                    (default: 0)
    #                :hdd - Hash containing disk usage information:
    #                       :disk - Amount of disk used in GB. (default: 0)
    #
    # Returns a Hash containing appropriate flavor IDs mapped to flavor names.
    def get_appropriate_flavors(resource_map = {})
      resource_map[:ram] ||= {mem_used: 0, swapping?: false}
      resource_map[:hdd] ||= {disk: 0}
      ram  = resource_map[:ram] * (resource_map[:ram][:swapping?] ? 2 : 1)
      disk = resource_map[:hdd][:disk] * 1.2

      @flavor_map.select do |id|
        @flavor_map[e][:ram] >= ram  && @flavor_map[e][:disk] >= disk
      end
    end

    private

    # Internal: Assemble a map of flavors and images available for
    # provisioning.
    #
    # fog - Fog Compute object used to obtain image/flavor mappings.
    #
    # Sets @image_map and @flavor_map.
    #
    # Returns nothing.
    def build_maps(fog)
      if fog.respond_to?(:images) && fog.respond_to?(:flavors)
        @image_map = fog.images.reduce({}) do |c,e|
          name, ver = map_image_id(e)
          c[name] ||= []
          c[name] << ver
          c
        end
        @flavor_map = fog.flavors.reduce({}) do |c,e|
          c.merge({e.id => { ram: e.ram, disk: e.disk }})
        end
      else
        @image_map  = {}
        @flavor_map = {}
      end
    end

    # Internal: Convert a Fog Image Object to a tuple for easy selection later.
    #
    # image - Fog Image object.
    #
    # Returns an Array containing a String and a Hash.
    def map_image_id(image)
      name, _ = image.name.split(/ \d/, 2)
      other = image.name.gsub(Regexp.new("^#{name} ?"), '')
      version, extra = other.split(/ +/, 2)
      [name, { version => { :id => image.id, :extra => extra } } ]
    end
  end
end; end; end
